# lst = ["pooh", "christopher robin", "piglet", "roo", "eeyore"]

# def reverse_list(lst):
#     l = 0
#     r = len(lst) - 1 

#     while r > l:
#         tem = lst[l]
#         lst[l] = lst[r]
#         lst[r] = tem

#         r -= 1
#         l += 1

#     return

# print(reverse_list(lst))

# items = ["extract of malt", "haycorns", "honey", "thistle", "thistle"]

# def remove_dupes(items):
#     map = {}
#     for i in range(len(items)):
#         if item is not map:
#              map[item[i]] = 1
#              if item is map:
#                  items.pop(i)
#                  i -= 1




# print(remove_dupes(items))


# def sort_by_parity(nums):
#     evenNums = []
#     oddNums = []

#     for i in range(len(nums)):
#         if (nums[i] % 2) == 0:
#             evenNums.append(nums[i])

#         else:
#             oddNums.append(nums[i])

#     return evenNums + oddNums

# nums = [3, 1, 2, 4]
# print(sort_by_parity(nums))

# nums = [0]
# print(sort_by_parity(nums))



# def most_endangered(species_list):
    
#     tempdict = species_list[0]
#     for i in species_list[1:]:
#         if i["population"] < tempdict["population"]:
#             tempdict = i
#     return tempdict["name"]

            

# species_list = [
#     {"name": "Amur Leopard",
#      "habitat": "Temperate forests",
#      "population": 84
#     },
#     {"name": "Javan Rhino",
#      "habitat": "Tropical forests",
#      "population": 72
#     },
#     {"name": "Vaquita",
#      "habitat": "Marine",
#      "population": 10
#     }
# ]

# print(most_endangered(species_list))



# def count_endangered_species(endangered_species, observed_species):
    
# >>> dict_a = {'a': 1, 'b': 2}
# >>> dict_b = {'b': 3, 'c': 4}
# >>> dict_c = {**dict_a, **dict_b}
# >>> dict_c

# duplicates.update({next_item : venue2_schedule[next_item]})

# def best_set(votes):
    
#     dict = {}
#     for items in votes:
#         if items.value != dict.get(items.value):
            
#         else: 
#             count += 1
#             items.update({items.value: count})


# def extract_nft_names(nft_collection):
#     nft_names = []
#     for nft in nft_collection:
#         nft_names.append(nft["name"])
#     return nft_names

# nft_collection = [
#     {"name": "Abstract Horizon", "creator": "ArtByAlex", "value": 5.4},
#     {"name": "Pixel Dreams", "creator": "DreamyPixel", "value": 7.2}
# ]

# nft_collection_2 = [
#     {"name": "Golden Hour", "creator": "SunsetArtist", "value": 8.9}
# ]

# nft_collection_3 = []

# print(extract_nft_names(nft_collection))
# print(extract_nft_names(nft_collection_2))
# print(extract_nft_names(nft_collection_3))

# def process_nft_queue(nft_queue):
    


# nft_queue = [
#     {"name": "Abstract Horizon", "processing_time": 2},
#     {"name": "Pixel Dreams", "processing_time": 3},
#     {"name": "Urban Jungle", "processing_time": 1}
# ]
# print(process_nft_queue(nft_queue))

# nft_queue_2 = [
#     {"name": "Golden Hour", "processing_time": 4},
#     {"name": "Sunset Serenade", "processing_time": 2},
#     {"name": "Ocean Waves", "processing_time": 3}
# ]
# print(process_nft_queue(nft_queue_2))

# nft_queue_3 = [
#     {"name": "Crypto Kitty", "processing_time": 5},
#     {"name": "Galactic Voyage", "processing_time": 6}
# ]
# print(process_nft_queue(nft_queue_3))

# def validate_nft_actions(actions):
#     x = []
#     if actions[0] == "remove":
#         return False
#     else:
#         for action in actions:
#             if action == "add":
#                 x.append(action)
#             if action == "remove":
#                 if not x:
#                     return False
#                 else:
#                     x.pop()
#         if len(x) == 0:
#             return True
#         else:
#             return False

            



# actions = ["add", "add", "remove", "remove"]
# actions_2 = ["add", "remove", "add", "remove"]
# actions_3 = ["add", "remove", "remove", "add"]

# print(validate_nft_actions(actions))
# print(validate_nft_actions(actions_2))
# print(validate_nft_actions(actions_3))


# class Villager:
#     def __init__(self, name, species, catchphrase):
#         self.name = name
#         self.species = species
#         self.catchphrase = catchphrase
#         self.furniture = []
    

# bones = Villager("Bones", "Dog", "yip yip")


# print(apollo.name)  
# print(apollo.species)  
# print(apollo.catchphrase) 
# print(apollo.furniture) 

# def greet_player(self, player_name):
#     return f"{self.name}: Hey there, {player_name}! How's it going, {self.catchphrase}!"


# print(bones.name)
# print(bones.species)  
# print(bones.catchphrase) 
# print(bones.furniture) 

# print(greet_player(bones, "matt"))


# class Node:
#     def __init__(self, value, next=None):
#         self.value = value
#         self.next = next

# # For testing
# def print_linked_list(head):
#     current = head
#     while current:
#         print(current.value, end=" -> " if current.next else "\n")
#         current = current.next

# def add_first(head, task):
#     old_node = head
    
#     head = Node(task)
#     head.next = old_node
#     return head


# task_1 = Node("shake tree")
# task_2 = Node("dig fossils")
# task_3 = Node("catch bugs")
# task_1.next = task_2
# task_2.next = task_3

# # Linked List: shake tree -> dig fossils -> catch bugs
# print_linked_list(add_first(task_1, "check turnip prices"))
    
# class Node:
#     def __init__(self, value, next=None):
#         self.value = value
#         self.next = next

# # For testing
# def print_linked_list(head):
#     current = head
#     while current:
#         print(current.value, end=" -> " if current.next else "\n")
#         current = current.next

# def halve_list(head):
#     current = head
#     while current:
#         current.value /= 2
#         current = current.next
#     return head


# node_one = Node(5)
# node_two = Node(6)
# node_three = Node(7)
# node_one.next = node_two
# node_two.next = node_three

# def count_suits_iterative(suits):
#     current = suits
#     count = 0

#     for values in current:
#         count += 1
#     return count

# def count_suits_recursive(suits):
#     if len(suits) == 0:
#         return 0
    
#     return 1 + count_suits_recursive(suits[1:])

# print(count_suits_iterative(["Mark I", "Mark II", "Mark III"]))
# print(count_suits_recursive(["Mark I", "Mark I", "Mark III", "Mark IV"]))


# def sum_stones(stones):
#     if len(stones) == 0:
#         return 0
#     return stones[0] + sum_stones(stones[1:])


# print(sum_stones([5, 10, 15, 20, 25, 30]))
# print(sum_stones([12, 8, 22, 16, 10]))

# def count_suits_iterative(suits):
#     return len(set(suits))

# def count_suits_recursive(suits):
#     if len(suits) == 0:
#         return 0
#     if suits[0] in suits[1:]:
#         return count_suits_recursive(suits[1:])
#     else:
#         return 1 + count_suits_recursive(suits[1:])
    
    

# print(count_suits_iterative(["Mark I", "Mark II", "Mark III"]))
# print(count_suits_recursive(["Mark I", "Mark I", "Mark III"]))

# def fibonacci_growth(n):
#     if n <= 1:
#         return n
#     return fibonacci_growth(n - 1)  + fibonacci_growth(n - 2)

# print(fibonacci_growth(5))
# print(fibonacci_growth(8))

# def power_of_four(n):
#     if n == 0:
#         return 1
#     if n < 0:
#         return 1 / power_of_four(-n)
#     return 4 * power_of_four(n - 1)

# print(power_of_four(2))
# print(power_of_four(-2))

# def strongest_avenger(strengths):
#     if len(strengths) == 0:
#         return 0
#     max_val = strongest_avenger(strengths[1])
#     if strengths[0] > max_val:
#         return strengths[0]
#     else:
#         return max_val
   

# print(strongest_avenger([88, 92, 95, 99, 97, 100, 94]))
# print(strongest_avenger([50, 75, 85, 60, 90]))

# # Input List: 5 -> 6 -> 7
# print_linked_list(halve_list(node_one))
